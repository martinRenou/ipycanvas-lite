{"version":3,"sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/docprovider/lib/yprovider.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/docprovider/lib/mock.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/docprovider/lib/tokens.js"],"names":["WebSocketProviderWithLocks","options","super","url","guid","ymodel","ydoc","awareness","this","_currentLockRequest","_initialContentRequest","messageHandlers","encoder","decoder","provider","emitSynced","messageType","timestamp","decoding","lockRequest","resolve","initialContent","byteLength","setTimeout","doc","initialContentRequest","_isInitialized","_onConnectionStatus","bind","on","promise","reject","Promise","_resolve","_reject","_sendMessage","Uint8Array","encoding","intervalID","setInterval","wsconnected","_finally","clearInterval","then","lock","message","send","ws","once","status","acquireLock","requestInitialContent","putInitializedState","releaseLock","ProviderMock","IDocumentProviderFactory","Token"],"mappings":"sRAWO,MAAMA,UAAmC,IAM5C,YAAYC,GACRC,MAAMD,EAAQE,IAAKF,EAAQG,KAAMH,EAAQI,OAAOC,KAAM,CAClDC,UAAWN,EAAQI,OAAOE,YAE9BC,KAAKC,oBAAsB,KAC3BD,KAAKE,uBAAyB,KAE9BF,KAAKG,gBAAgB,KAAO,CAACC,EAASC,EAASC,EAAUC,EAAYC,KAEjE,MAAMC,EAAYC,EAAA,GAAoBL,GAChCM,EAAcX,KAAKC,oBACzBD,KAAKC,oBAAsB,KACvBU,GACAA,EAAYC,QAAQH,IAI5BT,KAAKG,gBAAgB,KAAO,CAACC,EAASC,EAASC,EAAUC,EAAYC,KAEjE,MAAMK,EAAiBH,EAAA,GAA8BL,GAEjDQ,EAAeC,WAAa,GAC5BC,YAAW,KACP,KAAcf,KAAKgB,IAAKH,KACzB,GAEP,MAAMI,EAAwBjB,KAAKE,uBACnCF,KAAKE,uBAAyB,KAC1Be,GACAA,EAAsBL,QAAQC,EAAeC,WAAa,IAGlEd,KAAKkB,gBAAiB,EACtBlB,KAAKmB,oBAAsBnB,KAAKmB,oBAAoBC,KAAKpB,MACzDA,KAAKqB,GAAG,SAAUrB,KAAKmB,qBAK3B,wBACI,GAAInB,KAAKE,uBACL,OAAOF,KAAKE,uBAAuBoB,QAEvC,IAAIV,EAASW,EACb,MAAMD,EAAU,IAAIE,SAAQ,CAACC,EAAUC,KACnCd,EAAUa,EACVF,EAASG,KASb,OAPA1B,KAAKE,uBAAyB,CAAEoB,UAASV,UAASW,UAClDvB,KAAK2B,aAAa,IAAIC,WAAW,CAAC,OAKlCb,YAAW,IAAMH,GAAQ,IAAQ,KAC1BU,EAKX,sBACI,MAAMlB,EAAUyB,EAAA,KAChBA,EAAA,GAAsBzB,EAAS,KAC/ByB,EAAA,GAAyBzB,EAAS,KAAsBJ,KAAKgB,MAC7DhB,KAAK2B,aAAaE,EAAA,GAAsBzB,IACxCJ,KAAKkB,gBAAiB,EAM1B,cACI,GAAIlB,KAAKC,oBACL,OAAOD,KAAKC,oBAAoBqB,QAEpCtB,KAAK2B,aAAa,IAAIC,WAAW,CAAC,OAElC,MAAME,EAAaC,aAAY,KACvB/B,KAAKgC,aAELhC,KAAK2B,aAAa,IAAIC,WAAW,CAAC,SAEvC,KACH,IAAIhB,EAASW,EACb,MAAMD,EAAU,IAAIE,SAAQ,CAACC,EAAUC,KACnCd,EAAUa,EACVF,EAASG,KAEb1B,KAAKC,oBAAsB,CAAEqB,UAASV,UAASW,UAC/C,MAAMU,EAAW,KACbC,cAAcJ,IAGlB,OADAR,EAAQa,KAAKF,EAAUA,GAChBX,EAOX,YAAYc,GACR,MAAMhC,EAAUyB,EAAA,KAEhBA,EAAA,GAAsBzB,EAAS,KAC/ByB,EAAA,GAAqBzB,EAASgC,GAE9BpC,KAAK2B,aAAaE,EAAA,GAAsBzB,IAO5C,aAAaiC,GAET,MAAMC,EAAO,KACTvB,YAAW,KACHf,KAAKgC,YACLhC,KAAKuC,GAAGD,KAAKD,GAGbrC,KAAKwC,KAAK,SAAUF,KAEzB,IAEPA,IAOJ,0BAA0BG,GACtB,GAAIzC,KAAKkB,gBAAoC,cAAlBuB,EAAOA,OAAwB,CACtD,MAAML,QAAapC,KAAK0C,oBACW1C,KAAK2C,yBAEpC3C,KAAK4C,sBAET5C,KAAK6C,YAAYT,KC5JtB,MAAMU,EACT,wBACI,OAAOtB,QAAQZ,SAAQ,GAE3B,uBAGA,cACI,OAAOY,QAAQZ,QAAQ,GAE3B,YAAYwB,IAGZ,YCTG,MAAMW,EAA2B,I,SAAIC,OAAM","file":"8542.8bcc8925fd1bb5b61fbe.js","sourcesContent":["/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\nimport * as Y from 'yjs';\nimport { WebsocketProvider } from 'y-websocket';\nimport * as decoding from 'lib0/decoding';\nimport * as encoding from 'lib0/encoding';\n/**\n * A class to provide Yjs synchronization over WebSocket.\n */\nexport class WebSocketProviderWithLocks extends WebsocketProvider {\n    /**\n     * Construct a new WebSocketProviderWithLocks\n     *\n     * @param options The instantiation options for a WebSocketProviderWithLocks\n     */\n    constructor(options) {\n        super(options.url, options.guid, options.ymodel.ydoc, {\n            awareness: options.ymodel.awareness\n        });\n        this._currentLockRequest = null;\n        this._initialContentRequest = null;\n        // Message handler that confirms when a lock has been acquired\n        this.messageHandlers[127] = (encoder, decoder, provider, emitSynced, messageType) => {\n            // acquired lock\n            const timestamp = decoding.readUint32(decoder);\n            const lockRequest = this._currentLockRequest;\n            this._currentLockRequest = null;\n            if (lockRequest) {\n                lockRequest.resolve(timestamp);\n            }\n        };\n        // Message handler that receives the initial content\n        this.messageHandlers[125] = (encoder, decoder, provider, emitSynced, messageType) => {\n            // received initial content\n            const initialContent = decoding.readTailAsUint8Array(decoder);\n            // Apply data from server\n            if (initialContent.byteLength > 0) {\n                setTimeout(() => {\n                    Y.applyUpdate(this.doc, initialContent);\n                }, 0);\n            }\n            const initialContentRequest = this._initialContentRequest;\n            this._initialContentRequest = null;\n            if (initialContentRequest) {\n                initialContentRequest.resolve(initialContent.byteLength > 0);\n            }\n        };\n        this._isInitialized = false;\n        this._onConnectionStatus = this._onConnectionStatus.bind(this);\n        this.on('status', this._onConnectionStatus);\n    }\n    /**\n     * Resolves to true if the initial content has been initialized on the server. false otherwise.\n     */\n    requestInitialContent() {\n        if (this._initialContentRequest) {\n            return this._initialContentRequest.promise;\n        }\n        let resolve, reject;\n        const promise = new Promise((_resolve, _reject) => {\n            resolve = _resolve;\n            reject = _reject;\n        });\n        this._initialContentRequest = { promise, resolve, reject };\n        this._sendMessage(new Uint8Array([125]));\n        // Resolve with true if the server doesn't respond for some reason.\n        // In case of a connection problem, we don't want the user to re-initialize the window.\n        // Instead wait for y-websocket to connect to the server.\n        // @todo maybe we should reload instead..\n        setTimeout(() => resolve(false), 1000);\n        return promise;\n    }\n    /**\n     * Put the initialized state.\n     */\n    putInitializedState() {\n        const encoder = encoding.createEncoder();\n        encoding.writeVarUint(encoder, 124);\n        encoding.writeUint8Array(encoder, Y.encodeStateAsUpdate(this.doc));\n        this._sendMessage(encoding.toUint8Array(encoder));\n        this._isInitialized = true;\n    }\n    /**\n     * Acquire a lock.\n     * Returns a Promise that resolves to the lock number.\n     */\n    acquireLock() {\n        if (this._currentLockRequest) {\n            return this._currentLockRequest.promise;\n        }\n        this._sendMessage(new Uint8Array([127]));\n        // try to acquire lock in regular interval\n        const intervalID = setInterval(() => {\n            if (this.wsconnected) {\n                // try to acquire lock\n                this._sendMessage(new Uint8Array([127]));\n            }\n        }, 500);\n        let resolve, reject;\n        const promise = new Promise((_resolve, _reject) => {\n            resolve = _resolve;\n            reject = _reject;\n        });\n        this._currentLockRequest = { promise, resolve, reject };\n        const _finally = () => {\n            clearInterval(intervalID);\n        };\n        promise.then(_finally, _finally);\n        return promise;\n    }\n    /**\n     * Release a lock.\n     *\n     * @param lock The lock to release.\n     */\n    releaseLock(lock) {\n        const encoder = encoding.createEncoder();\n        // reply with release lock\n        encoding.writeVarUint(encoder, 126);\n        encoding.writeUint32(encoder, lock);\n        // releasing lock\n        this._sendMessage(encoding.toUint8Array(encoder));\n    }\n    /**\n     * Send a new message to WebSocket server.\n     *\n     * @param message The message to send\n     */\n    _sendMessage(message) {\n        // send once connected\n        const send = () => {\n            setTimeout(() => {\n                if (this.wsconnected) {\n                    this.ws.send(message);\n                }\n                else {\n                    this.once('status', send);\n                }\n            }, 0);\n        };\n        send();\n    }\n    /**\n     * Handle a change to the connection status.\n     *\n     * @param status The connection status.\n     */\n    async _onConnectionStatus(status) {\n        if (this._isInitialized && status.status === 'connected') {\n            const lock = await this.acquireLock();\n            const contentIsInitialized = await this.requestInitialContent();\n            if (!contentIsInitialized) {\n                this.putInitializedState();\n            }\n            this.releaseLock(lock);\n        }\n    }\n}\n//# sourceMappingURL=yprovider.js.map","export class ProviderMock {\n    requestInitialContent() {\n        return Promise.resolve(false);\n    }\n    putInitializedState() {\n        /* nop */\n    }\n    acquireLock() {\n        return Promise.resolve(0);\n    }\n    releaseLock(lock) {\n        /* nop */\n    }\n    destroy() {\n        /* nop */\n    }\n}\n//# sourceMappingURL=mock.js.map","import { Token } from '@lumino/coreutils';\n/**\n * The default document provider token.\n */\nexport const IDocumentProviderFactory = new Token('@jupyterlab/docprovider:IDocumentProviderFactory');\n//# sourceMappingURL=tokens.js.map"],"sourceRoot":""}